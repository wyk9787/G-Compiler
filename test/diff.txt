1c1
< main(1)
---
> if (if (false) {true} else {false}) {(10.230000 + 0.770000)} else {if (false) {(3.000000 + (2.500000 / 2.000000))} else {(0.000000 / 0.000000)}}
0a1
> (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b))))
1c1
< ./test/exp_test/test10.src.temp:2.5: syntax error, unexpected [, expecting var
---
> 5
0a1
> ((let [fact : Int -> Int] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b)))))
1c1
< ./test/exp_test/test11.src.temp:1.1: syntax error, unexpected (, expecting let
---
> 125
0a1
> snd (fst ((((1 + 2), (3 + 2)), true)))
1c1
< ./test/exp_test/test12.src.temp:1.1-3: syntax error, unexpected snd, expecting let
---
> 5
0a1
> (let [pair_func : Int * Int -> Int] = (fun [x : Int * Int] : Int -> if ((fst (x) > snd (x))) {(fst (x) - snd (x))} else {(fst (x) + snd (x))}) in (let [x : Int * Int] = (3, 5) in pair_func(x)))
1c1
< ./test/exp_test/test13.src.temp:1.5: syntax error, unexpected [, expecting var
---
> 8
0a1
> empty? (cdr (4::3::1::{}:Int))
1c1
< ./test/exp_test/test14.src.temp:1.1-6: syntax error, unexpected empty, expecting let
---
> false
0a1
> (let [x : Boolean] = car (cdr (true::false::true::false::{}:Boolean)) in if (x) {cdr (1.500000::3.200000::4.600000::{}:Float)} else {car (2.700000::8.900000::10.100000::{}:Float)::{}:Float})
1c1
< ./test/exp_test/test15.src.temp:1.5: syntax error, unexpected [, expecting var
---
> {2.700000}:Float
0a1
> (let [list_sum : {Int} -> Int] = (rec f [l : {Int}] : Int -> if (empty? (l)) {0} else {(car (l) + f(cdr (l)))}) in (let [x : {Int}] = 1::2::3::4::5::{}:Int in list_sum(x)))
1c1
< ./test/exp_test/test16.src.temp:1.5: syntax error, unexpected [, expecting var
---
> 15
0a1
> (let [list_sum : {Int} -> Int] = (rec f [l : {Int}] : Int -> if (empty? (l)) {1} else {(car (l) * f(cdr (l)))}) in (let [x : {Int}] = 1::2::3::4::5::{}:Int in list_sum(x)::(1 + 2)::(3 + 4)::(5 + 6)::(7 + (8 * 9))::{}:Int))
1c1
< ./test/exp_test/test17.src.temp:1.5: syntax error, unexpected [, expecting var
---
> {120, 3, 7, 11, 79}:Int
0a1
> (let [inner_product : {Int} -> {Int} -> Int] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(lst1)(lst2))))
1c1
< ./test/exp_test/test18.src.temp:1.5: syntax error, unexpected [, expecting var
---
> 11
0a1
> (let [iota : Int -> {Int} -> {Int}] = (rec f1 [n : Int] : {Int} -> {Int} -> (fun [lst : {Int}] : {Int} -> if ((n == 0)) {lst} else {f1((n - 1))(n::lst)})) in (let [num : Int] = 10 in (let [list : {Int}] = {}:Int in iota(num)(list))))
1c1
< ./test/exp_test/test19.src.temp:1.5: syntax error, unexpected [, expecting var
---
> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}:Int
1c1
< main(1)
---
> if (if ((2.300000 <= 4.600000)) {true} else {(3 > 4)}) {(1 <= 3)} else {false}
1c1
< 1
---
> true
0a1
> (let [x : <Int>] = ref ((3 + 2)) in x := (!(x) + 10);x := (!(x) + 5);if ((!(x) > (!(x) / 2))) {!(x)} else {3})
1c1
< ./test/exp_test/test20.src.temp:1.5: syntax error, unexpected [, expecting var
---
> 20
0a1
> (let [x : <Int>] = ref (10) in (let [y : <{Int}>] = ref ({}:Int) in while ((!(x) > 0)) {y := !(x)::!(y);x := (!(x) - 1)};!(y)))
1c1
< ./test/exp_test/test21.src.temp:1.5: syntax error, unexpected [, expecting var
---
> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}:Int
0a1
> (let [res : <Int * Float>] = ref ((0, 0.000000)) in (let [l : <{Int * Float}>] = ref ((1, 2.000000)::(3, 4.000000)::(5, 6.000000)::{}:Int * Float) in (let [counter : <Int>] = ref (0) in while ((!(counter) < 3)) {res := ((fst (!(res)) + fst (car (!(l)))), (snd (!(res)) + snd (car (!(l)))));l := cdr (!(l));counter := (!(counter) + 1)};!(res))))
1c1
< ./test/exp_test/test22.src.temp:1.5: syntax error, unexpected [, expecting var
---
> (9, 12.000000)
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};(let [res : <Int * Float>] = ref ((0, 0.000000)) in (let [l : <{Int * Float}>] = ref ((1, 2.000000)::(3, 4.000000)::(5, 6.000000)::{}:Int * Float) in (let [counter : <Int>] = ref (0) in while ((!(counter) < 3)) {res := ((fst (!(res)) + fst (car (!(l)))), (snd (!(res)) + snd (car (!(l)))));l := cdr (!(l));counter := (!(counter) + 1)};((fst (!(res)) + factorial(5)) + max2(3)(4)))))
1c1
< ./test/exp_test/test23.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 133
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};{Int} -> Int list_sum= {(rec f [l : {Int}] : Int -> if (empty? (l)) {0} else {(car (l) + f(cdr (l)))})};{Int} -> {Int} -> Int inner_product= {(rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))}))};{Int} lst1= {1::2::3::4::{}:Int};{Int} lst2= {4::3::2::1::{}:Int};(let [res : <Int * Float>] = ref ((0, 0.000000)) in (let [l : <{Int * Float}>] = ref ((1, 2.000000)::(3, 4.000000)::(5, 6.000000)::{}:Int * Float) in (let [counter : <Int>] = ref (0) in while ((!(counter) < 3)) {res := ((fst (!(res)) + fst (car (!(l)))), (snd (!(res)) + snd (car (!(l)))));l := cdr (!(l));counter := (!(counter) + 1)};((((fst (!(res)) + factorial(5)) + max2(3)(4)) + list_sum(lst1)) + inner_product(lst1)(lst2)))))
1c1
< ./test/exp_test/test24.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 163
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};{Int} -> Int list_sum= {(rec f [l : {Int}] : Int -> if (empty? (l)) {0} else {(car (l) + f(cdr (l)))})};{Int} -> {Int} -> Int inner_product= {(rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))}))};{Int} lst1= {1::2::3::{}:Int};{Int} lst2= {3::0::2::{}:Int};Int sum1= {list_sum(lst1)};Int sum2= {list_sum(lst2)};Int ip= {inner_product(lst1)(lst2)};factorial(max2(max2(sum1)(sum2))(ip))
1c1
< ./test/exp_test/test25.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 362880
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};{Int} -> Int list_sum= {(rec f [l : {Int}] : Int -> if (empty? (l)) {0} else {(car (l) + f(cdr (l)))})};{Int} -> {Int} -> Int inner_product= {(rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))}))};{Int} lst1= {1::2::3::4::{}:Int};{Int} lst2= {4::3::2::1::{}:Int};(let [res : <Int * Float>] = ref ((0, 0.000000)) in (let [l : <{Int * Float}>] = ref ((1, 2.000000)::(3, 4.000000)::(5, 6.000000)::{}:Int * Float) in (let [counter : <Int>] = ref (0) in while ((!(counter) < 3)) {res := ((fst (!(res)) + fst (car (!(l)))), (snd (!(res)) + snd (car (!(l)))));l := cdr (!(l));counter := (!(counter) + 1)};((((fst (!(res)) + factorial(5)) + max2(3)(4)) + list_sum(lst1)) + inner_product(lst1)(lst2)))))
1c1
< ./test/exp_test/test26.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 163
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};[-] a= {struct {Int y=>4, Int x=>3, }};[-] b= {struct {Int y=>a.x, Int x=>a.y, }};(max2(b.x)(b.y) + b.x)
1c1
< ./test/exp_test/test27.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 8
0a1
> Int -> Int factorial= {(rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1})};Int -> Int -> Int max2= {(fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y}))};{Int} -> Int list_sum= {(rec f [l : {Int}] : Int -> if (empty? (l)) {0} else {(car (l) + f(cdr (l)))})};{Int} -> {Int} -> Int inner_product= {(rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))}))};[-] a= {struct {Int y=>4, Int x=>3, }};[-] b= {struct {Int y=>a.x, Int x=>a.y, }};{Int} lst1= {1::2::a.x::a.y::{}:Int};{Int} lst2= {b.x::b.y::2::1::{}:Int};(let [res : <Int * Float>] = ref ((0, 0.000000)) in (let [l : <{Int * Float}>] = ref ((1, 2.000000)::(3, 4.000000)::(5, 6.000000)::{}:Int * Float) in (let [counter : <Int>] = ref (0) in while ((!(counter) < 3)) {res := ((fst (!(res)) + fst (car (!(l)))), (snd (!(res)) + snd (car (!(l)))));l := cdr (!(l));counter := (!(counter) + 1)};((((fst (!(res)) + factorial(5)) + max2(3)(4)) + list_sum(lst1)) + inner_product(lst1)(lst2)))))
1c1
< ./test/exp_test/test28.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 163
0a1
> if ((2 >= 1)) {(3.600000 * 2.400000)} else {(5.000000 + (10.980000 / 7.200000))}
1c1
< ./test/exp_test/test3.src.temp:1.1-5: syntax error, unexpected tfloat, expecting let
---
> 8.64
0a1
> (((3 + (5 * 6)) - ((2 / 1) * 10)) + 6)
1c1
< ./test/exp_test/test4.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 19
0a1
> (((3 / 2) + (2 / 3)) - (0 * 10))
1c1
< ./test/exp_test/test5.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 1
0a1
> ((((2.100000 + 3.900000) / 2.000000) + 5.712000) - 2.712000)
1c1
< ./test/exp_test/test6.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 6
0a1
> (fun [x : unit] : Int -> (3 + 5))(())
1c1
< ./test/exp_test/test7.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 8
0a1
> (let [x : Int -> Int] = (rec f [x : Int] : Int -> if ((x <= 100)) {(x + f((x + 1)))} else {x}) in (let [a : Int] = 99 in x(a)))
1c1
< ./test/exp_test/test8.src.temp:1.1-3: syntax error, unexpected tint, expecting let
---
> 300
0a1
> (fun [x : unit] : unit -> ())(())
1d0
< ./test/exp_test/test9.src.temp:1.1: syntax error, unexpected (, expecting let
0a1
> ((let [fact : Int -> Float] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b)))))
1c1,2
< ./test/type_test/test1.src.temp:1.1: syntax error, unexpected (, expecting let
---
> In (let [fact : Int -> Float] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5))
> Expecting type Int -> Float, receiving type Int -> Int
0a1
> (let [inner_product : {Int} -> {Boolean} -> Int] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(lst1)(lst2))))
1c1,2
< ./test/type_test/test10.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In inner_product(lst1)(lst2)
> Expecting type {Boolean}, receiving type {Int}
0a1
> (let [inner_product : {Int} -> {Int} -> Int] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(car (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(lst1)(lst2))))
1c1,2
< ./test/type_test/test11.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In f1(car (l1))
> Expecting type {Int}, receiving type Int
0a1
> (let [inner_product : {Int} -> {Int} -> Int] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Float in inner_product(lst1)(lst2))))
1c1,2
< ./test/type_test/test12.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In 4::{}:Float
> Expecting type Float, receiving type Int
0a1
> (let [inner_product : {Int} -> {Int} -> Int] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(empty? (lst1))(lst2))))
1c1,2
< ./test/type_test/test13.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In inner_product(empty? (lst1))
> Expecting type {Int}, receiving type Boolean
0a1
> ((let [fact : Int -> Int] = (rec f [n : Int] : Float -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b)))))
1c1,2
< ./test/type_test/test2.src.temp:1.1: syntax error, unexpected (, expecting let
---
> In (n * f((n - 1)))
> Expecting type Int, receiving type Float
0a1
> ((let [fact : Int -> Int] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(3.000000)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b)))))
1c1,2
< ./test/type_test/test3.src.temp:1.1: syntax error, unexpected (, expecting let
---
> In fact(3.000000)
> Expecting type Int, receiving type Float
0a1
> ((let [fact : Int -> Int] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {true} else {y})) in (let [a : Int] = 5 in (let [b : Int] = 2 in max2(a)(b)))))
1c1,2
< ./test/type_test/test4.src.temp:1.1: syntax error, unexpected (, expecting let
---
> In if ((x > y)) {true} else {y}
> Expecting type Boolean, receiving type Int
0a1
> ((let [fact : Int -> Float] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5)) + (let [max2 : Int -> Int -> Int] = (fun [x : Int] : Int -> Int -> (fun [y : Int] : Int -> if ((x > y)) {x} else {y})) in (let [a : Int] = 5 in (let [b : Float] = 2.000000 in max2(a)(b)))))
1c1,2
< ./test/type_test/test5.src.temp:1.1: syntax error, unexpected (, expecting let
---
> In (let [fact : Int -> Float] = (rec f [n : Int] : Int -> if ((n > 0)) {(n * f((n - 1)))} else {1}) in fact(5))
> Expecting type Int -> Float, receiving type Int -> Int
0a1
> (let [pair_func : Int * Boolean -> Int] = (fun [x : Int * Int] : Int -> if ((fst (x) > snd (x))) {(fst (x) - snd (x))} else {(fst (x) + snd (x))}) in (let [x : Int * Int] = (3, 5) in pair_func(x)))
1c1,2
< ./test/type_test/test6.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In pair_func(x)
> Expecting type Int * Boolean, receiving type Int * Int
0a1
> (let [pair_func : Int * Int -> Int] = (fun [x : Int * Int] : Int -> if ((fst (x) > snd ((x + 3)))) {(fst (x) - snd (x))} else {(fst (x) + snd (x))}) in (let [x : Int * Int] = (3, 5) in pair_func(x)))
1c1,2
< ./test/type_test/test7.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In (x + 3)
> Expecting type Int or Float, receiving type Int * Int
0a1
> (let [pair_func : Int * Int -> Int] = (fun [x : Int * Int] : Int -> if ((fst (x) > snd (x))) {(fst (x) - snd (x))} else {(fst (x) + snd (x))}) in (let [x : Int * Int] = (3, 4) in pair_func((x + 3))))
1c1,2
< ./test/type_test/test8.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In (x + 3)
> Expecting type Int or Float, receiving type Int * Int
0a1
> (let [inner_product : {Int} -> {Int} -> Float] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(lst1)(lst2))))
1c1,2
< ./test/type_test/test9.src.temp:1.5: syntax error, unexpected [, expecting var
---
> In (let [inner_product : {Int} -> {Int} -> Float] = (rec f1 [l1 : {Int}] : {Int} -> Int -> (fun [l2 : {Int}] : Int -> if (empty? (l1)) {0} else {((car (l1) * car (l2)) + f1(cdr (l1))(cdr (l2)))})) in (let [lst1 : {Int}] = 1::2::{}:Int in (let [lst2 : {Int}] = 3::4::{}:Int in inner_product(lst1)(lst2))))
> Expecting type {Int} -> {Int} -> Float, receiving type {Int} -> {Int} -> Int
