let fact (n : int) : int = 
  if (n > 0) 
  then n * (fact (n-1))
  else 1
;;

let max2 (x : int, y : int) : int = 
  if x > y 
  then x
  else y
;;

let list_sum (l : {int}) : int =  
  if (empty? (l)) 
  then 0
  else car (l) + (list_sum cdr(l))
;;

let inner_product (l1 : {int}, l2 : {int}) : int =
  if (empty? (l1)) 
  then 0
  else car(l1) * car(l2) +  (inner_product (cdr(l1)) (cdr(l2)))
;;

let init(z : unit) : unit = 
  [-] a = {
    struct {
      int x => 3,
      int y => 4,
    }
  };

  [-] b = {
    struct {
      int x => a.y,
      int y => a.x,
    }
  };

  {int} lst1 = { 1 :: 2 :: a.x :: a.y :: {}:int };

  {int} lst2 = { b.x :: b.y :: 2 :: 1 :: {}:int }
;;

let main(a : int) : int = 
  let res: <int * float> = ref ( (0, 0.0) ) in
  let l : <{int * float}> = ref ( (1, 2.0) :: (3, 4.0) :: (5, 6.0) :: {} : int * float) in
  let counter : <int> = ref (0) in
  while (!(counter) < 3) do 
    res := (fst(!(res)) + fst(car(!(l))),  snd(!(res)) + snd(car(!(l))));
    l := cdr(!(l));
    counter := !(counter) + 1
  end;

  fst(!(res)) + (factorial 5) + (max2 3 4) + (list_sum lst1) + (inner_product lst1 lst2)
;;
